// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#include "game.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_game_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Build_game_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_game_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Card_game_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_game_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Dice_game_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_game_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Market_game_2eproto;
namespace game {
class VoidDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Void> _instance;
} _Void_default_instance_;
class OrderInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<OrderInfo> _instance;
} _OrderInfo_default_instance_;
class PlayerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Player> _instance;
} _Player_default_instance_;
class EventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Event> _instance;
  const ::game::Card* cardinfo_;
  const ::game::Dice* diceinfo_;
  const ::game::Market* marketinfo_;
  const ::game::Build* buildinfo_;
} _Event_default_instance_;
class CardDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Card> _instance;
} _Card_default_instance_;
class DiceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Dice> _instance;
} _Dice_default_instance_;
class MarketDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Market> _instance;
} _Market_default_instance_;
class BuildDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Build> _instance;
} _Build_default_instance_;
}  // namespace game
static void InitDefaultsscc_info_Build_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Build_default_instance_;
    new (ptr) ::game::Build();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Build::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Build_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Build_game_2eproto}, {}};

static void InitDefaultsscc_info_Card_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Card_default_instance_;
    new (ptr) ::game::Card();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Card::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Card_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Card_game_2eproto}, {}};

static void InitDefaultsscc_info_Dice_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Dice_default_instance_;
    new (ptr) ::game::Dice();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Dice::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Dice_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Dice_game_2eproto}, {}};

static void InitDefaultsscc_info_Event_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Event_default_instance_;
    new (ptr) ::game::Event();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Event::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Event_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Event_game_2eproto}, {
      &scc_info_Card_game_2eproto.base,
      &scc_info_Dice_game_2eproto.base,
      &scc_info_Market_game_2eproto.base,
      &scc_info_Build_game_2eproto.base,}};

static void InitDefaultsscc_info_Market_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Market_default_instance_;
    new (ptr) ::game::Market();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Market::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Market_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Market_game_2eproto}, {}};

static void InitDefaultsscc_info_OrderInfo_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_OrderInfo_default_instance_;
    new (ptr) ::game::OrderInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::OrderInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_OrderInfo_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_OrderInfo_game_2eproto}, {}};

static void InitDefaultsscc_info_Player_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Player_default_instance_;
    new (ptr) ::game::Player();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Player::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Player_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Player_game_2eproto}, {}};

static void InitDefaultsscc_info_Void_game_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::game::_Void_default_instance_;
    new (ptr) ::game::Void();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::game::Void::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Void_game_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Void_game_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_game_2eproto[8];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_game_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_game_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_game_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Void, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::OrderInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::OrderInfo, id_),
  PROTOBUF_FIELD_OFFSET(::game::OrderInfo, numberofplayers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::Player, playerid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Event, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::Event, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::Event, type_),
  PROTOBUF_FIELD_OFFSET(::game::Event, playerid_),
  offsetof(::game::EventDefaultTypeInternal, cardinfo_),
  offsetof(::game::EventDefaultTypeInternal, diceinfo_),
  offsetof(::game::EventDefaultTypeInternal, marketinfo_),
  offsetof(::game::EventDefaultTypeInternal, buildinfo_),
  PROTOBUF_FIELD_OFFSET(::game::Event, EventInfo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Card, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::Card, cardtype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Dice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::Dice, number_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Market, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::Market, requiredresource_),
  PROTOBUF_FIELD_OFFSET(::game::Market, ownedresource_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Build, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::game::Build, buildingtype_),
  PROTOBUF_FIELD_OFFSET(::game::Build, x_),
  PROTOBUF_FIELD_OFFSET(::game::Build, y_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::game::Void)},
  { 5, -1, sizeof(::game::OrderInfo)},
  { 12, -1, sizeof(::game::Player)},
  { 18, -1, sizeof(::game::Event)},
  { 30, -1, sizeof(::game::Card)},
  { 36, -1, sizeof(::game::Dice)},
  { 42, -1, sizeof(::game::Market)},
  { 49, -1, sizeof(::game::Build)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Void_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_OrderInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Player_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Event_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Card_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Dice_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Market_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::_Build_default_instance_),
};

const char descriptor_table_protodef_game_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ngame.proto\022\004game\"\006\n\004Void\"0\n\tOrderInfo\022"
  "\n\n\002id\030\001 \001(\005\022\027\n\017numberOfPlayers\030\002 \001(\005\"\032\n\006"
  "Player\022\020\n\010playerId\030\001 \001(\005\"\313\001\n\005Event\022\035\n\004ty"
  "pe\030\001 \001(\0162\017.game.EventType\022\020\n\010playerId\030\002 "
  "\001(\005\022\036\n\010cardInfo\030\003 \001(\0132\n.game.CardH\000\022\036\n\010d"
  "iceInfo\030\004 \001(\0132\n.game.DiceH\000\022\"\n\nmarketInf"
  "o\030\005 \001(\0132\014.game.MarketH\000\022 \n\tbuildInfo\030\006 \001"
  "(\0132\013.game.BuildH\000B\013\n\tEventInfo\"\030\n\004Card\022\020"
  "\n\010cardType\030\001 \001(\005\"\026\n\004Dice\022\016\n\006number\030\001 \001(\005"
  "\"9\n\006Market\022\030\n\020requiredResource\030\001 \001(\005\022\025\n\r"
  "ownedResource\030\002 \001(\005\"3\n\005Build\022\024\n\014building"
  "Type\030\001 \001(\005\022\t\n\001x\030\002 \001(\005\022\t\n\001y\030\003 \001(\005*_\n\tEven"
  "tType\022\010\n\004CARD\020\000\022\010\n\004DICE\020\001\022\n\n\006MARKET\020\002\022\t\n"
  "\005BUILD\020\003\022\013\n\007ENDTURN\020\004\022\r\n\tNEXTPHASE\020\005\022\013\n\007"
  "ENDGAME\020\0062\205\001\n\007Network\022)\n\010Register\022\n.game"
  ".Void\032\017.game.OrderInfo\"\000\022&\n\tSendEvent\022\013."
  "game.Event\032\n.game.Void\"\000\022\'\n\010GetEvent\022\014.g"
  "ame.Player\032\013.game.Event\"\000b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_game_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_game_2eproto_sccs[8] = {
  &scc_info_Build_game_2eproto.base,
  &scc_info_Card_game_2eproto.base,
  &scc_info_Dice_game_2eproto.base,
  &scc_info_Event_game_2eproto.base,
  &scc_info_Market_game_2eproto.base,
  &scc_info_OrderInfo_game_2eproto.base,
  &scc_info_Player_game_2eproto.base,
  &scc_info_Void_game_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_game_2eproto_once;
static bool descriptor_table_game_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto = {
  &descriptor_table_game_2eproto_initialized, descriptor_table_protodef_game_2eproto, "game.proto", 713,
  &descriptor_table_game_2eproto_once, descriptor_table_game_2eproto_sccs, descriptor_table_game_2eproto_deps, 8, 0,
  schemas, file_default_instances, TableStruct_game_2eproto::offsets,
  file_level_metadata_game_2eproto, 8, file_level_enum_descriptors_game_2eproto, file_level_service_descriptors_game_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_game_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_game_2eproto), true);
namespace game {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[0];
}
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Void::InitAsDefaultInstance() {
}
class Void::_Internal {
 public:
};

Void::Void()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Void)
}
Void::Void(const Void& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:game.Void)
}

void Void::SharedCtor() {
}

Void::~Void() {
  // @@protoc_insertion_point(destructor:game.Void)
  SharedDtor();
}

void Void::SharedDtor() {
}

void Void::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Void& Void::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Void_game_2eproto.base);
  return *internal_default_instance();
}


void Void::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Void)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear();
}

const char* Void::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Void::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Void)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Void)
  return target;
}

size_t Void::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Void)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Void::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Void)
  GOOGLE_DCHECK_NE(&from, this);
  const Void* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Void>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Void)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Void)
    MergeFrom(*source);
  }
}

void Void::MergeFrom(const Void& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Void)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Void::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Void)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Void::CopyFrom(const Void& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Void)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Void::IsInitialized() const {
  return true;
}

void Void::InternalSwap(Void* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Void::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void OrderInfo::InitAsDefaultInstance() {
}
class OrderInfo::_Internal {
 public:
};

OrderInfo::OrderInfo()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.OrderInfo)
}
OrderInfo::OrderInfo(const OrderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&numberofplayers_) -
    reinterpret_cast<char*>(&id_)) + sizeof(numberofplayers_));
  // @@protoc_insertion_point(copy_constructor:game.OrderInfo)
}

void OrderInfo::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&numberofplayers_) -
      reinterpret_cast<char*>(&id_)) + sizeof(numberofplayers_));
}

OrderInfo::~OrderInfo() {
  // @@protoc_insertion_point(destructor:game.OrderInfo)
  SharedDtor();
}

void OrderInfo::SharedDtor() {
}

void OrderInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OrderInfo& OrderInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_OrderInfo_game_2eproto.base);
  return *internal_default_instance();
}


void OrderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:game.OrderInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&numberofplayers_) -
      reinterpret_cast<char*>(&id_)) + sizeof(numberofplayers_));
  _internal_metadata_.Clear();
}

const char* OrderInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 numberOfPlayers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          numberofplayers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OrderInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.OrderInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // int32 numberOfPlayers = 2;
  if (this->numberofplayers() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_numberofplayers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.OrderInfo)
  return target;
}

size_t OrderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.OrderInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());
  }

  // int32 numberOfPlayers = 2;
  if (this->numberofplayers() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_numberofplayers());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OrderInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.OrderInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const OrderInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<OrderInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.OrderInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.OrderInfo)
    MergeFrom(*source);
  }
}

void OrderInfo::MergeFrom(const OrderInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.OrderInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.id() != 0) {
    _internal_set_id(from._internal_id());
  }
  if (from.numberofplayers() != 0) {
    _internal_set_numberofplayers(from._internal_numberofplayers());
  }
}

void OrderInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.OrderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OrderInfo::CopyFrom(const OrderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.OrderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderInfo::IsInitialized() const {
  return true;
}

void OrderInfo::InternalSwap(OrderInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(id_, other->id_);
  swap(numberofplayers_, other->numberofplayers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Player::InitAsDefaultInstance() {
}
class Player::_Internal {
 public:
};

Player::Player()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  playerid_ = from.playerid_;
  // @@protoc_insertion_point(copy_constructor:game.Player)
}

void Player::SharedCtor() {
  playerid_ = 0;
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:game.Player)
  SharedDtor();
}

void Player::SharedDtor() {
}

void Player::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Player& Player::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Player_game_2eproto.base);
  return *internal_default_instance();
}


void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Player)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  playerid_ = 0;
  _internal_metadata_.Clear();
}

const char* Player::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Player::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Player)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Player)
  return target;
}

size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Player)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->playerid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_playerid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Player::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Player)
  GOOGLE_DCHECK_NE(&from, this);
  const Player* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Player>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Player)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Player)
    MergeFrom(*source);
  }
}

void Player::MergeFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Player)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.playerid() != 0) {
    _internal_set_playerid(from._internal_playerid());
  }
}

void Player::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(playerid_, other->playerid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Event::InitAsDefaultInstance() {
  ::game::_Event_default_instance_.cardinfo_ = const_cast< ::game::Card*>(
      ::game::Card::internal_default_instance());
  ::game::_Event_default_instance_.diceinfo_ = const_cast< ::game::Dice*>(
      ::game::Dice::internal_default_instance());
  ::game::_Event_default_instance_.marketinfo_ = const_cast< ::game::Market*>(
      ::game::Market::internal_default_instance());
  ::game::_Event_default_instance_.buildinfo_ = const_cast< ::game::Build*>(
      ::game::Build::internal_default_instance());
}
class Event::_Internal {
 public:
  static const ::game::Card& cardinfo(const Event* msg);
  static const ::game::Dice& diceinfo(const Event* msg);
  static const ::game::Market& marketinfo(const Event* msg);
  static const ::game::Build& buildinfo(const Event* msg);
};

const ::game::Card&
Event::_Internal::cardinfo(const Event* msg) {
  return *msg->EventInfo_.cardinfo_;
}
const ::game::Dice&
Event::_Internal::diceinfo(const Event* msg) {
  return *msg->EventInfo_.diceinfo_;
}
const ::game::Market&
Event::_Internal::marketinfo(const Event* msg) {
  return *msg->EventInfo_.marketinfo_;
}
const ::game::Build&
Event::_Internal::buildinfo(const Event* msg) {
  return *msg->EventInfo_.buildinfo_;
}
void Event::set_allocated_cardinfo(::game::Card* cardinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_EventInfo();
  if (cardinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cardinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cardinfo, submessage_arena);
    }
    set_has_cardinfo();
    EventInfo_.cardinfo_ = cardinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:game.Event.cardInfo)
}
void Event::set_allocated_diceinfo(::game::Dice* diceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_EventInfo();
  if (diceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      diceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diceinfo, submessage_arena);
    }
    set_has_diceinfo();
    EventInfo_.diceinfo_ = diceinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:game.Event.diceInfo)
}
void Event::set_allocated_marketinfo(::game::Market* marketinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_EventInfo();
  if (marketinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      marketinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marketinfo, submessage_arena);
    }
    set_has_marketinfo();
    EventInfo_.marketinfo_ = marketinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:game.Event.marketInfo)
}
void Event::set_allocated_buildinfo(::game::Build* buildinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_EventInfo();
  if (buildinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buildinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildinfo, submessage_arena);
    }
    set_has_buildinfo();
    EventInfo_.buildinfo_ = buildinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:game.Event.buildInfo)
}
Event::Event()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&type_)) + sizeof(playerid_));
  clear_has_EventInfo();
  switch (from.EventInfo_case()) {
    case kCardInfo: {
      _internal_mutable_cardinfo()->::game::Card::MergeFrom(from._internal_cardinfo());
      break;
    }
    case kDiceInfo: {
      _internal_mutable_diceinfo()->::game::Dice::MergeFrom(from._internal_diceinfo());
      break;
    }
    case kMarketInfo: {
      _internal_mutable_marketinfo()->::game::Market::MergeFrom(from._internal_marketinfo());
      break;
    }
    case kBuildInfo: {
      _internal_mutable_buildinfo()->::game::Build::MergeFrom(from._internal_buildinfo());
      break;
    }
    case EVENTINFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.Event)
}

void Event::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Event_game_2eproto.base);
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&playerid_) -
      reinterpret_cast<char*>(&type_)) + sizeof(playerid_));
  clear_has_EventInfo();
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:game.Event)
  SharedDtor();
}

void Event::SharedDtor() {
  if (has_EventInfo()) {
    clear_EventInfo();
  }
}

void Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Event& Event::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Event_game_2eproto.base);
  return *internal_default_instance();
}


void Event::clear_EventInfo() {
// @@protoc_insertion_point(one_of_clear_start:game.Event)
  switch (EventInfo_case()) {
    case kCardInfo: {
      delete EventInfo_.cardinfo_;
      break;
    }
    case kDiceInfo: {
      delete EventInfo_.diceinfo_;
      break;
    }
    case kMarketInfo: {
      delete EventInfo_.marketinfo_;
      break;
    }
    case kBuildInfo: {
      delete EventInfo_.buildinfo_;
      break;
    }
    case EVENTINFO_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EVENTINFO_NOT_SET;
}


void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Event)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&playerid_) -
      reinterpret_cast<char*>(&type_)) + sizeof(playerid_));
  clear_EventInfo();
  _internal_metadata_.Clear();
}

const char* Event::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .game.EventType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::game::EventType>(val));
        } else goto handle_unusual;
        continue;
      // int32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .game.Card cardInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cardinfo(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .game.Dice diceInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_diceinfo(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .game.Market marketInfo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_marketinfo(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .game.Build buildInfo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_buildinfo(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Event::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Event)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.EventType type = 1;
  if (this->type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // int32 playerId = 2;
  if (this->playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_playerid(), target);
  }

  // .game.Card cardInfo = 3;
  if (_internal_has_cardinfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cardinfo(this), target, stream);
  }

  // .game.Dice diceInfo = 4;
  if (_internal_has_diceinfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::diceinfo(this), target, stream);
  }

  // .game.Market marketInfo = 5;
  if (_internal_has_marketinfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::marketinfo(this), target, stream);
  }

  // .game.Build buildInfo = 6;
  if (_internal_has_buildinfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::buildinfo(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Event)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .game.EventType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 playerId = 2;
  if (this->playerid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_playerid());
  }

  switch (EventInfo_case()) {
    // .game.Card cardInfo = 3;
    case kCardInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *EventInfo_.cardinfo_);
      break;
    }
    // .game.Dice diceInfo = 4;
    case kDiceInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *EventInfo_.diceinfo_);
      break;
    }
    // .game.Market marketInfo = 5;
    case kMarketInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *EventInfo_.marketinfo_);
      break;
    }
    // .game.Build buildInfo = 6;
    case kBuildInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *EventInfo_.buildinfo_);
      break;
    }
    case EVENTINFO_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Event::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Event)
  GOOGLE_DCHECK_NE(&from, this);
  const Event* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Event>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Event)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Event)
    MergeFrom(*source);
  }
}

void Event::MergeFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Event)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from.playerid() != 0) {
    _internal_set_playerid(from._internal_playerid());
  }
  switch (from.EventInfo_case()) {
    case kCardInfo: {
      _internal_mutable_cardinfo()->::game::Card::MergeFrom(from._internal_cardinfo());
      break;
    }
    case kDiceInfo: {
      _internal_mutable_diceinfo()->::game::Dice::MergeFrom(from._internal_diceinfo());
      break;
    }
    case kMarketInfo: {
      _internal_mutable_marketinfo()->::game::Market::MergeFrom(from._internal_marketinfo());
      break;
    }
    case kBuildInfo: {
      _internal_mutable_buildinfo()->::game::Build::MergeFrom(from._internal_buildinfo());
      break;
    }
    case EVENTINFO_NOT_SET: {
      break;
    }
  }
}

void Event::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(type_, other->type_);
  swap(playerid_, other->playerid_);
  swap(EventInfo_, other->EventInfo_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Card::InitAsDefaultInstance() {
}
class Card::_Internal {
 public:
};

Card::Card()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Card)
}
Card::Card(const Card& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cardtype_ = from.cardtype_;
  // @@protoc_insertion_point(copy_constructor:game.Card)
}

void Card::SharedCtor() {
  cardtype_ = 0;
}

Card::~Card() {
  // @@protoc_insertion_point(destructor:game.Card)
  SharedDtor();
}

void Card::SharedDtor() {
}

void Card::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Card& Card::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Card_game_2eproto.base);
  return *internal_default_instance();
}


void Card::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Card)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cardtype_ = 0;
  _internal_metadata_.Clear();
}

const char* Card::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 cardType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          cardtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Card::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Card)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 cardType = 1;
  if (this->cardtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_cardtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Card)
  return target;
}

size_t Card::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Card)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 cardType = 1;
  if (this->cardtype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_cardtype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Card::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Card)
  GOOGLE_DCHECK_NE(&from, this);
  const Card* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Card>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Card)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Card)
    MergeFrom(*source);
  }
}

void Card::MergeFrom(const Card& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Card)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.cardtype() != 0) {
    _internal_set_cardtype(from._internal_cardtype());
  }
}

void Card::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Card)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Card::CopyFrom(const Card& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Card)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Card::IsInitialized() const {
  return true;
}

void Card::InternalSwap(Card* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(cardtype_, other->cardtype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Card::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Dice::InitAsDefaultInstance() {
}
class Dice::_Internal {
 public:
};

Dice::Dice()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Dice)
}
Dice::Dice(const Dice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  number_ = from.number_;
  // @@protoc_insertion_point(copy_constructor:game.Dice)
}

void Dice::SharedCtor() {
  number_ = 0;
}

Dice::~Dice() {
  // @@protoc_insertion_point(destructor:game.Dice)
  SharedDtor();
}

void Dice::SharedDtor() {
}

void Dice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Dice& Dice::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Dice_game_2eproto.base);
  return *internal_default_instance();
}


void Dice::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Dice)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  number_ = 0;
  _internal_metadata_.Clear();
}

const char* Dice::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Dice::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Dice)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 number = 1;
  if (this->number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Dice)
  return target;
}

size_t Dice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Dice)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 number = 1;
  if (this->number() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_number());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Dice::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Dice)
  GOOGLE_DCHECK_NE(&from, this);
  const Dice* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Dice>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Dice)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Dice)
    MergeFrom(*source);
  }
}

void Dice::MergeFrom(const Dice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Dice)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.number() != 0) {
    _internal_set_number(from._internal_number());
  }
}

void Dice::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Dice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Dice::CopyFrom(const Dice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Dice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dice::IsInitialized() const {
  return true;
}

void Dice::InternalSwap(Dice* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(number_, other->number_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Dice::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Market::InitAsDefaultInstance() {
}
class Market::_Internal {
 public:
};

Market::Market()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Market)
}
Market::Market(const Market& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&requiredresource_, &from.requiredresource_,
    static_cast<size_t>(reinterpret_cast<char*>(&ownedresource_) -
    reinterpret_cast<char*>(&requiredresource_)) + sizeof(ownedresource_));
  // @@protoc_insertion_point(copy_constructor:game.Market)
}

void Market::SharedCtor() {
  ::memset(&requiredresource_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ownedresource_) -
      reinterpret_cast<char*>(&requiredresource_)) + sizeof(ownedresource_));
}

Market::~Market() {
  // @@protoc_insertion_point(destructor:game.Market)
  SharedDtor();
}

void Market::SharedDtor() {
}

void Market::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Market& Market::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Market_game_2eproto.base);
  return *internal_default_instance();
}


void Market::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Market)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&requiredresource_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ownedresource_) -
      reinterpret_cast<char*>(&requiredresource_)) + sizeof(ownedresource_));
  _internal_metadata_.Clear();
}

const char* Market::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 requiredResource = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          requiredresource_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 ownedResource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ownedresource_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Market::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Market)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 requiredResource = 1;
  if (this->requiredresource() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_requiredresource(), target);
  }

  // int32 ownedResource = 2;
  if (this->ownedresource() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_ownedresource(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Market)
  return target;
}

size_t Market::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Market)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 requiredResource = 1;
  if (this->requiredresource() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_requiredresource());
  }

  // int32 ownedResource = 2;
  if (this->ownedresource() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ownedresource());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Market::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Market)
  GOOGLE_DCHECK_NE(&from, this);
  const Market* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Market>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Market)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Market)
    MergeFrom(*source);
  }
}

void Market::MergeFrom(const Market& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Market)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.requiredresource() != 0) {
    _internal_set_requiredresource(from._internal_requiredresource());
  }
  if (from.ownedresource() != 0) {
    _internal_set_ownedresource(from._internal_ownedresource());
  }
}

void Market::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Market)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Market::CopyFrom(const Market& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Market)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Market::IsInitialized() const {
  return true;
}

void Market::InternalSwap(Market* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(requiredresource_, other->requiredresource_);
  swap(ownedresource_, other->ownedresource_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Market::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Build::InitAsDefaultInstance() {
}
class Build::_Internal {
 public:
};

Build::Build()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:game.Build)
}
Build::Build(const Build& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&buildingtype_, &from.buildingtype_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&buildingtype_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:game.Build)
}

void Build::SharedCtor() {
  ::memset(&buildingtype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&buildingtype_)) + sizeof(y_));
}

Build::~Build() {
  // @@protoc_insertion_point(destructor:game.Build)
  SharedDtor();
}

void Build::SharedDtor() {
}

void Build::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Build& Build::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Build_game_2eproto.base);
  return *internal_default_instance();
}


void Build::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Build)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&buildingtype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&buildingtype_)) + sizeof(y_));
  _internal_metadata_.Clear();
}

const char* Build::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 buildingType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          buildingtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Build::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Build)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 buildingType = 1;
  if (this->buildingtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_buildingtype(), target);
  }

  // int32 x = 2;
  if (this->x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // int32 y = 3;
  if (this->y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Build)
  return target;
}

size_t Build::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Build)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 buildingType = 1;
  if (this->buildingtype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_buildingtype());
  }

  // int32 x = 2;
  if (this->x() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_x());
  }

  // int32 y = 3;
  if (this->y() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_y());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Build::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:game.Build)
  GOOGLE_DCHECK_NE(&from, this);
  const Build* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Build>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:game.Build)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:game.Build)
    MergeFrom(*source);
  }
}

void Build::MergeFrom(const Build& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.Build)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.buildingtype() != 0) {
    _internal_set_buildingtype(from._internal_buildingtype());
  }
  if (from.x() != 0) {
    _internal_set_x(from._internal_x());
  }
  if (from.y() != 0) {
    _internal_set_y(from._internal_y());
  }
}

void Build::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:game.Build)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Build::CopyFrom(const Build& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Build)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Build::IsInitialized() const {
  return true;
}

void Build::InternalSwap(Build* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(buildingtype_, other->buildingtype_);
  swap(x_, other->x_);
  swap(y_, other->y_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Build::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::game::Void* Arena::CreateMaybeMessage< ::game::Void >(Arena* arena) {
  return Arena::CreateInternal< ::game::Void >(arena);
}
template<> PROTOBUF_NOINLINE ::game::OrderInfo* Arena::CreateMaybeMessage< ::game::OrderInfo >(Arena* arena) {
  return Arena::CreateInternal< ::game::OrderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Player* Arena::CreateMaybeMessage< ::game::Player >(Arena* arena) {
  return Arena::CreateInternal< ::game::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Event* Arena::CreateMaybeMessage< ::game::Event >(Arena* arena) {
  return Arena::CreateInternal< ::game::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Card* Arena::CreateMaybeMessage< ::game::Card >(Arena* arena) {
  return Arena::CreateInternal< ::game::Card >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Dice* Arena::CreateMaybeMessage< ::game::Dice >(Arena* arena) {
  return Arena::CreateInternal< ::game::Dice >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Market* Arena::CreateMaybeMessage< ::game::Market >(Arena* arena) {
  return Arena::CreateInternal< ::game::Market >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Build* Arena::CreateMaybeMessage< ::game::Build >(Arena* arena) {
  return Arena::CreateInternal< ::game::Build >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
